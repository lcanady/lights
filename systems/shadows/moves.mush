/*
#############################################################################
### MOVES ###################################################################
  
  This file has all of the commands and functions relative to the +moves
  system for the PbTA Engine.

  TODO: See if I need to add a notes section.
  TODO: Also See about moving move data over to it's own dedicated object.
  
  Syntax:
    +categories/add <item>[,<item>[,<itemN>]]
    +categories/del <item>[,<item>[,<itemN>]]

    +archetypes/add <item>[,<item>[,<itemN>]]
    +achettypes/del <item>[,<item>[,<itemN>]]

    +moves/add <title>/<category>=<archetype>
    +moves/del <title>=<archetype>
    
    +moves <category>[:<archetype>]
??  +moves <title>

#############################################################################
*/


/*
=============================================================================
=== Command: +<categories>|<archetypes>/add <item>[,<itemN>] ================

  Add a list of archetypes or categories to the PBtA Rules Engine.
  
  registers:
    %0: The entire regex match
    %1: The type of add (archetype or category)
    %2: Operation (add or del)
    %3: The list

=============================================================================
*/

&cmd.moves/categories #us =$\+(archetypes|categories)\/(add|del)\s*?(.*):
  @include %!/wiz_check=%#;

  // If this is an add request, process it.
  @if strmatch(lcstr(%2), add) = {
    
    [setq(0, iter(%3, trim(##),%,,|))];
    // Figure out the type we're adding too.
    @switch/first lcstr(%1) = 
      cat*, { 
        &categories #us = setunion(v(categories), lcstr(%q0), |, |);
        @pemit %#=[v(prompt)] Categorie%(s%) added: 
          %ch[itemize(caplist(%q0, |), |)]%cn.
      },
      arc*, {
        &archetypes #us = setunion(v(archetypes), lcstr(%q0), |, |);
        @pemit %#=[v(prompt)] Archetype%(s%) added: 
          %ch[itemize(caplist(%q0,|), |)]%cn.
      }
  }

@set #us/cmd.moves/categories = Reg


/*
=============================================================================
=== Command: +moves/add <title>/<category>=<Archetype> ======================

  Add/Edit a new move to the move database. We don't want any copyright
  infringement or anything, so we won't be saving the details of the moves,
  just the title, faction and category.  For details consult the book!

  registers:
    %0: Title
    %1: Category
    %2: Archetype (Or All)

=============================================================================
*/

&cmd.moves/add #us = $+moves/add */*=*:
  @include %!/wiz_check = %#;

  // Does the category exist?
  @assert match(get(#us/categories),%1, |) = {
    @pemit %#=[v(prompt-error)] That's not a valid category.
  };

  // Does the archetype match one listed, or 'all'?
  @assert
    or(
      match(
        get(%!/archetypes), %2, |
      ),
      match(all, lcstr(%2))
    ) = {
      @pemit %#=[v(prompt-err)] That's not a valid archetype.
    };

  // Add the move to the proper list.
  &moves-[edit(%2,%b,_)] #us =
    setunion(
      v(moves-[edit(%2,%b,_)]),
      [lcstr(%0)]~[%1], |
    );

  @pemit %#= [v(prompt)] Move: %ch[caplist(%0)]%cn
    %ch%(%cn[ucstr(%1)]%ch%)%cn added to archetype:
    %ch[capstr(%2)]%cn.


/*
=============================================================================
=== +moves ==================================================================

  list the moves based on basic search criteria.  To aearch for most moves,
  the system only needs the category, basic, debt, etc unless looking up
  information for archetype and corruptions moves.  Those haave to be
  specified in the `+moves <category>:<detail>`  So `+moves archetype/the vamp`

  registers:
    %0: The category to search for.
    %q<name>: The name of the category.
    %q<detail>: The specific detail.

=============================================================================
*/


&cmd.moves #us = $+moves *:

  // Before anything we need to make sure we're not dealing with a two part rg.
  [setq(+, before(%0,:), name)]
  [setq(+, after(%0, :), detail)];
  @assert match(v(categories), %q<name>, |) = {
    @pemit %#=[v(prompt-err)] That's nota valid category.
      valid categories are: [itemize(v(categories),|)].
  };

  // capture the archetype if there is one.  Else, all.
  [setq(+,switch(gt(words(%q<detail>),0), 1, trim(%q<detail>), all), arc)];

  // Make sure it's a valid archetype.
  @assert match(v(archetypes), lcstr(%q<arc>), |) = {
    @pemit %#=%chValid archetypes are:%cn [itemize(v(archetypes),|)].
  };

  @pemit %#=
    [setq(+, %ch[capstr(%q<name>)]%cn moves for %ch[caplist(%q<arc>)]%cn, title)]
    [u(
      fn.moves.display,
        %q<name>,
        %q<arc>,
        %q<title>
    )]

&fn.move.titles #us =
  [sort(
    map(
      fn.trim.move,
      filter(fn.filter.moves, v(moves-[edit(%1,%b,_)]), |,,%0), |
    ),,|
  )]

&fn.moves.display #us =
  [u(#gfo/header-c, %2)]%r
  [u(fn.twocol,u(fn.move.titles, %0, %1))]%r[u(#gfo/header)]%r
  %ch%cy*%cn Valid Categories are: %ch[itemize(caplist(v(categories), |), |)]%cn.




&fn.filter.moves #us = match(%0, *~[lcstr(%1)], |)
&fn.twocol  #us = columns(%0,38,2,,,,,,,,|)
&fn.trim.move #us= caplist(edit(first(%0,~),_,%b))


